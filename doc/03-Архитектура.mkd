Классы
======

Код должен писаться на C# с применением классов (а иначе на C# и не получится).

Вот, какие классы потребуются:

- парсер файла, описывающего уровни;
- абстрактный класс объекта уровня;
- конкретные классы каждого из объектов уровня;
- фабрика объектов;
- абстрактный класс эффекта;
- конкретные классы эффектов;
- фабрика эффектов;
- создатель уровня;
- класс игрока;
- класс уровня;
- класс основной логики.

Объект уровня описывает единичную ячейку уровня. Эффект определяет визуальное и/или звуковое событие.

-----------------------

## Парсер файла, описывающего уровни ##############

Логика работы:

1. Разбиваем весь файл на строки.
2. Удаляем строку, содержащую /\* GAMELEVEL \*/ (слово GAMELEVEL - вместо XPM). Проверяем, что это самая первая строка в файле.
3. Следующая строка должна начинаться на **static char * ** и заканчиваться символами **_xpm[] = {**. Все, что между этими символами - название уровня. Удаляем строку.
4. Со всех остальных строк снимаем:
    - первый символ, который должен быть двойной кавычкой;
    - проверяем последний символ. Если это **"};** - значит эту строку считаем последней и после нее прекращаем обработку. Удаляем эту последовательность символов;
    - иначе последними символами должны являться **",**. Если это так - удаляем их.
5. Первая из оставшихся строк - четыре числа, разделенные пробелом. Получаем **ширину**, **высоту**, **количество цветов**, **количество символов в цвете**. Проверяем, что количество символов в цвете == 1. Удаляем строку.
6. Проверяем, что **высота** равна количеству оставшихся строк.
7. По следующим **количество цветов** строк составляем словарь:
    - первый символ - **код цвета**, дальше **разделитель** (символ табуляции, "c", пробел) и **описание**. Удаляем строку.
8. Оставшиеся строки представляют собой сам уровень.
    - организуем цикл по всем строкам **высота**;
    - цикл по всем столбцам **ширина**;
    - берем символ [строка][столбец] и сохраняем его во внутренний массив;
    - удаляем строку.
9. Если парсер на каком-либо из шагов алгоритма обнаружил ошибку, внутренний массив обнуляется, и размеры **ширина** и **высота** устанавливаются в ноль.
10. По требованию извне (публичный метод) по указанной ячейке [строка][столбец] выдаем соответствующее хранимому символу с этими координатами **описание** текстовой строкой.
11. По требованию извне (публичный метод) предоставляется результат проверки корректности парсинга уровня: (0 < **ширина** * **высота**).

------------------

## Класс игрока

Представляет хранилище всех свойств, ассоциированных с игроком, а также реализацию всех его интерфейсов.

Свойства игрока:

- общее количество проведенного в игре времени;
- общее количество сделанных в игре шагов;
- лучший результат по этому уровню за все игры (шаги и ставшееся время);
- оставшееся количество времени до конца текущего уровня;
- количество шагов, проделанное в этом уровне в текущей игре;
- текущие координаты на уровне (ячейка: строка, столбец; азимут направления взгляда: куда будет сделан следующий шаг).


Интерфейсы игрока:

- перемещение по уровню;
- зрение;
- подсветка уровня.

### Интерфейс *Перемещение игрока по уровню*

--------------------------------------------------------

## Абстрактный класс объекта уровня ##############

Описывает обобщенную единицу, на основании информации о которой будет создана ячейка игрового уровня.

Должен содержать следующие свойства:

- **описание**. Текстовая строка, соответствующая аналогичной из файла описания уровня, но без суффикса;
- **ориентация**. Азимут поворота объекта. Определяется суффиксом из описания в файле уровня;
- **проходимость**. Признак того, является ли ячейка безусловным препятствием на пути игрока (грубо: стена - не стена);
- **пенальти**. Количество очков, отнимаемые у игрока за посещение данной ячейки (не актуально для классов, у которых **проходимость** == false);
- **эффекты**. Массив ссылок на объекты эффектов. Объект может не иметь ни одного эффекта, например, пустое пространство. Хотя, даже пустое пространство может иметь эффект "звук шагов".


Также должны быть реализованы следующие методы:

- регистрация объекта в фабрике. Каждый из классов наследников должен вызывать этот метод для того, чтобы фабрика объектов узнала о новом объекте, описываемым этим классом;
- .